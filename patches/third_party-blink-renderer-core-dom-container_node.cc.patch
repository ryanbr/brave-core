diff --git a/third_party/blink/renderer/core/dom/container_node.cc b/third_party/blink/renderer/core/dom/container_node.cc
index 696c6d0f8db1cdbeac35d4597eea9f1cbb63e30b..f89f5b5c1314afbe1a928fe5bb963d49d23a84ba 100644
--- a/third_party/blink/renderer/core/dom/container_node.cc
+++ b/third_party/blink/renderer/core/dom/container_node.cc
@@ -61,6 +61,14 @@
 #include "third_party/blink/renderer/platform/bindings/v8_per_isolate_data.h"
 #include "third_party/blink/renderer/platform/runtime_enabled_features.h"
 
+#include "brave/third_party/blink/brave_page_graph/buildflags/buildflags.h"
+#if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+#include "third_party/blink/renderer/core/dom/document.h"
+#include "third_party/blink/renderer/core/dom/dom_node_ids.h"
+#include "brave/third_party/blink/brave_page_graph/page_graph.h"
+#endif
+#include <iostream>
+
 namespace blink {
 
 static void DispatchChildInsertionEvents(Node&);
@@ -931,6 +939,52 @@ void ContainerNode::NotifyNodeInsertedInternal(
   ScriptForbiddenScope forbid_script;
 
   for (Node& node : NodeTraversal::InclusiveDescendantsOf(root)) {
+#if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+    {
+      ::brave_page_graph::PageGraph* page_graph = GetDocument().GetPageGraph();
+      if (page_graph != nullptr) {
+        const NodeType node_type = node.getNodeType();
+        const bool is_html_elm_node = (node_type == kElementNode ||
+            node_type == kDocumentFragmentNode ||
+            node_type == kDocumentTypeNode);
+        const bool is_html_text_node = (is_html_elm_node == false &&
+            (node_type == kTextNode || node_type == kCommentNode));
+
+        if (is_html_elm_node || is_html_text_node) {
+          const DOMNodeId node_id = DOMNodeIds::IdForNode(&node);
+          Node* const parent = node.parentNode();
+          DOMNodeId parent_node_id =
+            (parent && (parent->IsElementNode() || parent->IsDocumentNode()))
+            //(parent && (parent->IsElementNode()))
+            ? DOMNodeIds::IdForNode(parent)
+            : 0;
+          Node* const sibling = node.previousSibling();
+          const DOMNodeId sibling_node_id = (sibling)
+            ? DOMNodeIds::IdForNode(sibling)
+            : 0;
+
+          /*
+          std::cout << "NotifyNodeInsertedInternal: " << (void*)parent;
+          if (node.IsElementNode()) {
+            Element *e = reinterpret_cast<Element*>(&node);
+            std::cout << ", node tag " << e->tagName();
+          } else {
+            std::cout << ", node name " << node.nodeName();
+          }
+          std::cout << "\n";
+          */
+
+          if (is_html_elm_node) {
+            page_graph->RegisterHTMLElementNodeInserted(
+              node_id, parent_node_id, sibling_node_id);
+          } else {
+            page_graph->RegisterHTMLTextNodeInserted(
+              node_id, parent_node_id, sibling_node_id);
+          }
+        }
+      }
+    }
+#endif
     // As an optimization we don't notify leaf nodes when when inserting
     // into detached subtrees that are not in a shadow tree.
     if (!isConnected() && !IsInShadowTree() && !node.IsContainerNode())
@@ -952,6 +1006,19 @@ void ContainerNode::NotifyNodeRemoved(Node& root) {
     // As an optimization we skip notifying Text nodes and other leaf nodes
     // of removal when they're not in the Document tree and not in a shadow root
     // since the virtual call to removedFrom is not needed.
+#if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+    if (GetDocument().GetPageGraph() != nullptr) {
+      const NodeType node_type = node.getNodeType();
+      if (node_type == kElementNode || node_type == kDocumentFragmentNode) {
+        GetDocument().GetPageGraph()->RegisterHTMLElementNodeRemoved(
+          DOMNodeIds::IdForNode(&node));
+      } else {
+        GetDocument().GetPageGraph()->RegisterHTMLTextNodeRemoved(
+          DOMNodeIds::IdForNode(&node));
+      }
+    }
+#endif
+
     if (!node.IsContainerNode() && !node.IsInTreeScope())
       continue;
     node.RemovedFrom(*this);
